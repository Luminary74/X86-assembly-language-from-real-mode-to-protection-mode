## c05_mbr.asm

```
         ;代码清单5-1 
         ;文件名：c05_mbr.asm
         ;文件说明：硬盘主引导扇区代码
         ;创建日期：2011-3-31 21:15 
         
         mov ax,0xb800                 ;指向文本模式的显示缓冲区
         mov es,ax
 
         ;以下显示字符串"Label offset:"
         mov byte [es:0x00],'L'
         mov byte [es:0x01],0x07
         mov byte [es:0x02],'a'
         mov byte [es:0x03],0x07
         mov byte [es:0x04],'b'
         mov byte [es:0x05],0x07
         mov byte [es:0x06],'e'
         mov byte [es:0x07],0x07
         mov byte [es:0x08],'l'
         mov byte [es:0x09],0x07
         mov byte [es:0x0a],' '
         mov byte [es:0x0b],0x07
         mov byte [es:0x0c],"o"
         mov byte [es:0x0d],0x07
         mov byte [es:0x0e],'f'
         mov byte [es:0x0f],0x07
         mov byte [es:0x10],'f'
         mov byte [es:0x11],0x07
         mov byte [es:0x12],'s'
         mov byte [es:0x13],0x07
         mov byte [es:0x14],'e'
         mov byte [es:0x15],0x07
         mov byte [es:0x16],'t'
         mov byte [es:0x17],0x07
         mov byte [es:0x18],':'
         mov byte [es:0x19],0x07
 
         mov ax,number                 ;取得标号number的偏移地址
         mov bx,10
 
         ;设置数据段的基地址
         mov cx,cs
         mov ds,cx
 
         ;求个位上的数字
         mov dx,0
         div bx
         mov [0x7c00+number+0x00],dl   ;保存个位上的数字
 
         ;求十位上的数字
         xor dx,dx
         div bx
         mov [0x7c00+number+0x01],dl   ;保存十位上的数字
 
         ;求百位上的数字
         xor dx,dx
         div bx
         mov [0x7c00+number+0x02],dl   ;保存百位上的数字
 
         ;求千位上的数字
         xor dx,dx
         div bx
         mov [0x7c00+number+0x03],dl   ;保存千位上的数字
 
         ;求万位上的数字 
         xor dx,dx
         div bx
         mov [0x7c00+number+0x04],dl   ;保存万位上的数字
 
         ;以下用十进制显示标号的偏移地址
         mov al,[0x7c00+number+0x04]
         add al,0x30
         mov [es:0x1a],al
         mov byte [es:0x1b],0x04
         
         mov al,[0x7c00+number+0x03]
         add al,0x30
         mov [es:0x1c],al
         mov byte [es:0x1d],0x04
         
         mov al,[0x7c00+number+0x02]
         add al,0x30
         mov [es:0x1e],al
         mov byte [es:0x1f],0x04
 
         mov al,[0x7c00+number+0x01]
         add al,0x30
         mov [es:0x20],al
         mov byte [es:0x21],0x04
 
         mov al,[0x7c00+number+0x00]
         add al,0x30
         mov [es:0x22],al
         mov byte [es:0x23],0x04
         
         mov byte [es:0x24],'D'
         mov byte [es:0x25],0x07
          
   infi: jmp near infi                 ;无限循环
      
  number db 0,0,0,0,0
  
  times 203 db 0
            db 0x55,0xaa
```

上面是源代码，可以利用nasm工具编译该程序将生成c05_mbr.bin和生成c05_mbr.list列表文件。

使用课程配套的fixvhdw工具将编译出的主引导扇区程序写入虚拟硬盘的主引导扇区。

配合使用Bochs虚拟机调试主引导扇区程序。

具体操作自行学习。

下面直接看代码。

可以先行了解一下[为什么主引导记录的内存地址是0x7C00？](http://www.ruanyifeng.com/blog/2015/09/0x7c00.html)



### 程序功能

程序中的如下代码段是实现在屏幕上显示“Label offset:”字符串

```
mov ax,0xb800 ;指向文本模式的显示缓冲区
mov es,ax
 
;以下显示字符串"Label offset:"
mov byte [es:0x00],'L'
mov byte [es:0x01],0x07
mov byte [es:0x02],'a'
mov byte [es:0x03],0x07
mov byte [es:0x04],'b'
; 略
```

要把字符显示在屏幕上，就是要借助显卡显示到屏幕上。显卡分为图像模式和文本模式两种基本工作模式。

在文本模式中，为了方便显存的访问，地址空间中的0xB8000~0xBFFFF被映射到显存。

通俗的来讲，0xB8000~0xBFFFF这段内存里写的东西会显示在屏幕上。按照一定的字符编码格式，就可以达到你想要的结果。

说明：在文本模式中，每个字符的编码由ASCII码（1B）+ 显示属性（1B）构成，ASCII码大家比较熟悉，显示属性的1B分为高低4位，分别描述字符颜色（前景色）和底色（背景色）。具体自行查阅。



### 初始化段寄存器

由于已经把显存映射到处理器内存空间，所以可以像访问内存一样访问显存。和8086CPU中学习的访问方式一致，[段地址：偏移地址]的方式访问。

显卡的起始地址为0xB8000，因此设置0xB8000为段地址。

```
mov ax,0xb800                 ;指向文本模式的显示缓冲区
mov es,ax
```

这里和之前一样，由于设计原因，处理器不允许一个立即数直接传给段寄存器，只允许使用通用寄存器或内存单元设置段寄存器。

mov 段寄存器, 通用寄存器
mov 段寄存器, [内存地址]

至于为啥，个人认为应该是，为了给定一个标准，更合法正式。多一个步骤，能够减少编程人员的错误率。



### 显示字符的实现

将要显示的字符及其显示属性写入显存

```
mov byte [es:0x00],'L'
mov byte [es:0x01],0x07
```

 在指令中使用字符的字面值要加单引号

段超越前缀es：

​	由于显存的段地址在ES段寄存器中，因此在生成物理地址时，我们肯定希望使用ES段寄存器。

​	在不指定段寄存器的情况下，处理器访问内存时默认使用DS寄存器。

​	段超越前缀用于指定使用的段寄存器。

​	附加段寄存器ES就是用于这种需要同时使用2个数据段的场景，如果没有ES寄存器，则只能不断修改DS寄存器的值，以指向要访问的数据段。

关键字byte：

​	关键字byte用来说明本次传送的单位为字节，word 字 dword 双字（4B） qword 4字 （8B）

什么情况下需要指定传送长度

​	当指令本身无法判断传输的长度时，需要指定传送长度。

```
mov [es:0x01],0x07
```

​	此时既可以解释为将立即数0x07传送到[es:0x01]字节，也可以解释为将立即数0x007传送到[es:0x01]开始的字节中

​	如果操作数的长度确定，则无需修饰

```
mov [0x00], al ;按字节操作
mov ax, [0x02] ;按字操作
```

### MOV指令使用小结

mov指令用于数据传送，传送指令**只影响目的操作数的内容，不改变源操作数的内容**，指令格式如下，

```
mov 目的操作数[寄存器 / 内存地址], 源操作数[寄存器 / 内存地址 / 立即数]
```


使用过程中，需要注意如下事项：


① mov指令可以在寄存器之间传送数据，但是寄存器的宽度必须相同

```
mov ax, bl ;编译错误，寄存器宽度不同
```


② mov指令可以将内存中的数据传送到寄存器，默认段地址在DS中


③ mov指令可以将立即数传送到寄存器


④ mov指令可以将寄存器中的内容传送到指定的内存中，操作宽度取决于寄存器宽度

```
mov [0x0c], dx ;传输2B
mov [0x20], ah ;传输1B 
```


⑤ mov指令可以将立即数传送到指定的内存单元，同时需要指定操作宽度

```
mov byte [0x02], 0xe9 ;按字节操作
mov word [0x06], 0x3c ;按字操作
```


⑥ mov指令的目的操作数不能是立即数

⑦ mov指令的源操作数和目的操作数不能同时为内存单元

```
mov [0x01], [0x02] ;编译报错
```

不仅是mov指令，其他指令也都不支持在两个内存单元之间直接进行操作

⑧ 不可直接访问指令指针寄存器IP，IP不能出现在任何指令中，只能间接修改（e.g. 通过跳转指令）

```
mov ip, 0xf000 ;编译报错
```


⑨ 如果目的操作数是段寄存器，则源操作数必须是通用寄存器或内存单元，不能是立即数



说明：处理器为什么不支持内存单元之间的直接操作

一种理解是，支持内存单元之间的直接操作会增加处理器的复杂度，但是收益不大，和通过2条指令实现传输并无区别。



### 在屏幕上显示数字

实现屏幕上显示number标号的偏移地址

```
mov ax,number ;取得标号number的偏移地址
mov bx,10
 
;设置数据段的基地址，与代码段相同
mov cx,cs
mov ds,cx
 
;求个位上的数字
mov dx,0
div bx
mov [0x7c00+number+0x00],dl   ;保存个位上的数字
 
;求十位上的数字
xor dx,dx
div bx
mov [0x7c00+number+0x01],dl   ;保存十位上的数字
 
;求百位上的数字
xor dx,dx
div bx
mov [0x7c00+number+0x02],dl   ;保存百位上的数字
 
;求千位上的数字
xor dx,dx
div bx
mov [0x7c00+number+0x03],dl   ;保存千位上的数字
 
;求万位上的数字 
xor dx,dx
div bx
mov [0x7c00+number+0x04],dl   ;保存万位上的数字
 
;以下用十进制显示标号的偏移地址
mov al,[0x7c00+number+0x04]
add al,0x30
mov [es:0x1a],al
mov byte [es:0x1b],0x04
         
mov al,[0x7c00+number+0x03]
add al,0x30
mov [es:0x1c],al
mov byte [es:0x1d],0x04
         
mov al,[0x7c00+number+0x02]
add al,0x30
mov [es:0x1e],al
mov byte [es:0x1f],0x04
 
mov al,[0x7c00+number+0x01]
add al,0x30
mov [es:0x20],al
mov byte [es:0x21],0x04
 
mov al,[0x7c00+number+0x00]
add al,0x30
mov [es:0x22],al
mov byte [es:0x23],0x04
         
mov byte [es:0x24],'D'
mov byte [es:0x25],0x07
 
number db 0,0,0,0,0
```



我们可以利用，之前nasm生成的列表文件方便更好的分析。

说明：什么是汇编地址


① 对于任何一个内存段，段地址可以开始于任何**16B**对齐的地址，偏移地址则总是从**0x0000**开始递增


② 为了支持这种内存访问模式，在源程序编译阶段，编译器会将程序整体上作为一个独立的段来处理，并从0开始计算每条指令的地址


③ 该地址在编译阶段计算确定，因此称为汇编地址

④ 汇编地址标识该指令相对于段起始处的距离，以字节计算。当编译后的程序装入物理内存后，又标识了该指令在内存段中的偏移地址



### 汇编地址与偏移地址的关系

汇编地址：指令和数据在编译出的二进制文件中，相对于段起始处的偏移量
偏移地址：指令和数据在加载到内存中运行时，相对于段寄存器中的段地址的偏移量

① 程序在运行前，需要先加载到某个内存段中，如果将程序加载到段的起始地址处，则汇编地址等于偏移地址

② 如果程序并不是加载到内存段的起始地址处，则偏移地址和汇编地址之间有一个固定的偏移量

标号就是汇编地址的符号化

### 如何显示十进制数

假设有标号代表的汇编的地址为65535，要在屏幕上显示该数字，是无法直接显示的，无法直接显示。

所以我们需要首先分解出各个数位，然后再去显示各个数位。

需要注意的是，这里分解出来的数位是数字，不是数字字符。需要加上0x30转换成ASCII码对应的数字字符显示。

我们用数字去除10得到的余数，就能拿到我们想要的。

div除法（只能是无符号数）

如果在指令中指定的是**8位的寄存器或者8位操作数的内存地址**，则被除数必须在AX寄存器中，即类型为16位二进制数除以8位二进制数：

AL=商，AH=余数

```
div bh;  // AX/bh
div byte[0x2002];  // AX/[0x2002]
```

此时我们拿AH的值就行。

如果在指令中指定的是**16位寄存器或者16位操作数的内存地址**，则意味着被除数是32位，其中低16位在AX寄存器中，高16位在DX寄存器中

AX=商，DX=余数

```
div bx ;  // DX : AX / bx
div word [0x2002]
```

DX为段寄存器，里面放的本来是段基址。

来看代码：

```
mov ax,number ;取得标号number的偏移地址
mov bx,10
mov dx,0  // 设置段寄存器为0
div bx
```

将number表示的汇编地址存储在AX寄存器，将DX寄存器设置为0，这样DX : AX构成32位被除数

number表示的汇编地址为16位，为什么要用32位除法呢?

因为16位的无符号数最大值为65535，与10相除的商为6553，超过了8位寄存器能表示的范围，所以此处使用了32位除法



只使用余数的低8位

32位除法中，余数保存在DX（DH+DL）中，但是示例代码仅使用了低8位

```cpp
mov [0x7c00+number+0x00],dl ;保存个位上的数字
```

这是因为此处的余数为0 ~ 9，只用到了DL寄存器，所以只保存了1B



### 在程序中声明并初始化数据

使用db伪指令预留了5B内存，用于存储分解出的数位

```
number db 0,0,0,0,0
```

之所以要预留空间存储位数，是因为分解数位时是从低位到高位，而显示时是从高位到地位，因此需要暂存分解出的位数。而又没有足够的寄存器暂存数位，所以使用内存暂存



### 显示分解出的数位

```
;设置数据段的基地址，与代码段相同
mov cx,cs
mov ds,cx
 
mov al,[0x7c00+number+0x04] ; 去除分解出数位的最高位
add al,0x30 ; 将数位转换为ASCII数字字符
mov [es:0x1a],al ; 将数字字符写入显存
mov byte [es:0x1b],0x04 ; 
```

cs:ip是当前的段地址和偏移地址



### 异或指令xor

```
xor dx,dx
```

由于32位除法中，将余数存储在DX寄存器中，破坏了其中的内容，所以在示例代码中使用异或指令将DX寄存器清零



### 将程序进入无限循环

```
infi: jmp near infi ;无限循环
```

让程序执行流程进入无限循环

### 为什么要进入无限循环

在示例代码中，没有区分数据段和代码段，或者说他们是重叠的。因此编译出的二进制文件中包含了不可执行的数据，而处理器是不停取指执行的
所以我们希望程序在执行完必要操作后，能进入一个无限循环

### 跳转指令

使用段间直接绝对跳转指令进入无限循环

```cpp
infi:
    jmp 0x0000:0x7c00 + infi
```


进入无限循环，就是让jmp指令跳转到自身所在的地址。由于此处需要给出直接绝对地址，所以在标号的基础上加0x7C00



### 写入MBR有效标识

将MBR的第510 & 511字节（从0开始）分别设置为0x55 & 0xaa

这是标识一个主引导扇区有效的标志

```
times 203 db 0
db 0x55,0xaa
```

times伪指令用来重复后面的指令若干次，此处就是预留203个字节，目的是确保在510 & 511字节写入0xaa55

根据list文件，times伪指令的偏移量为0x133，即307D。除去MBR有效标识的2B，MBR共需510B，所以应当填充（510 - 307 = 203B）

上面通过list文件计算的方式很不灵活，如果之前的程序有增减，此处的预留字节数就需要重新手工计算


我们也可以通过标号计算，实现如下，

```
start: ; start标号位于整个程序起始处
    ; 程序主体
current:
    times 510 - (current - start) db 0
```


